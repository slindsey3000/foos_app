<%# SEO Meta Tags for Brackets Page %>
<% content_for :title, "Foosball Tournament Brackets | USA Foosball Championships" %>
<% content_for :description, "View current foosball tournament brackets and championship results. Follow USA Foosball tournaments and competitive play across America." %>
<% content_for :keywords, "foosball brackets, foosball tournaments, foosball championships, tournament results, competitive foosball, USA foosball tournaments" %>

<%# Structured Data for Brackets Page %>
<% content_for :structured_data do %>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebPage",
  "name": "Foosball Tournament Brackets",
  "description": "View current foosball tournament brackets and championship results",
  "url": "<%= request.original_url %>",
  "mainEntity": {
    "@type": "SportsEvent",
    "name": "USA Foosball Tournaments",
    "description": "Competitive foosball tournaments and championships"
  }
}
</script>
<% end %>

<style>
  :root {
    color-scheme: light dark;
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
  }

  #tournament-manager-root {
    background: #f5f5f5;
    color: #222;
  }

  #tournament-manager-root .app {
    max-width: 1200px;
    margin: 0 auto;
    padding: 24px;
    display: flex;
    flex-direction: column;
    gap: 24px;
  }

  #tournament-manager-root header {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  #tournament-manager-root header h1 {
    margin: 0;
    font-size: 1.8rem;
  }

  #tournament-manager-root header p {
    margin: 0;
    color: #555;
  }

  #tournament-manager-root .panel {
    background: #ffffff;
    border-radius: 12px;
    border: 1px solid #d9d9d9;
    padding: 16px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.04);
  }

  #tournament-manager-root .panel h2 {
    margin: 0 0 12px 0;
    font-size: 1.2rem;
  }

  #tournament-manager-root .inputs {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    gap: 12px;
    align-items: end;
  }

  #tournament-manager-root .inputs .field {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  #tournament-manager-root label {
    font-weight: 600;
    font-size: 0.85rem;
  }

  #tournament-manager-root .name-inputs {
    display: grid;
    gap: 6px;
  }

  #tournament-manager-root .name-inputs input[type="text"] {
    width: 100%;
  }

  #tournament-manager-root .name-inputs .player-partner-input {
    display: none;
  }

#tournament-manager-root tr.is-doubles .name-inputs .player-partner-input {
    display: block;
  }

  #tournament-manager-root .intro-overlay {
    position: fixed;
    inset: 0;
    background: rgba(15, 23, 42, 0.58);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 24px;
    z-index: 20;
    backdrop-filter: blur(4px);
  }

  #tournament-manager-root .intro-overlay.hidden {
    display: none;
  }

  #tournament-manager-root .intro-card {
    background: #fff;
    width: min(760px, 100%);
    border-radius: 16px;
    padding: 24px 28px;
    box-shadow: 0 28px 64px rgba(15, 23, 42, 0.25);
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  #tournament-manager-root .intro-header {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  #tournament-manager-root .intro-header h2 {
    margin: 0;
    font-size: 1.6rem;
  }

  #tournament-manager-root .intro-grid {
    display: grid;
    gap: 16px;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  }

  #tournament-manager-root .intro-player-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
    max-height: 260px;
    overflow-y: auto;
    padding-right: 6px;
  }

  #tournament-manager-root .intro-player-row {
    display: grid;
    grid-template-columns: 1fr repeat(2, minmax(90px, auto));
    gap: 12px;
    align-items: center;
    padding: 10px 12px;
    border: 1px solid #e5e7eb;
    border-radius: 10px;
    background: #f8fafc;
  }

  #tournament-manager-root .intro-player-row input[type="text"] {
    width: 100%;
  }

  #tournament-manager-root .intro-player-row .paid-checkbox {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.85rem;
  }

  #tournament-manager-root .intro-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    justify-content: flex-end;
  }

  #tournament-manager-root .note-text {
    font-size: 0.82rem;
    color: #4b5563;
  }

  #tournament-manager-root select,
  #tournament-manager-root input[type="text"],
  #tournament-manager-root input[type="number"] {
    border-radius: 8px;
    border: 1px solid #c9c9c9;
    padding: 8px 10px;
    font-size: 0.95rem;
    background: #fff;
  }

   #tournament-manager-root input[type="number"]::-webkit-outer-spin-button,
   #tournament-manager-root input[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  #tournament-manager-root .players-table {
    width: 100%;
    border-collapse: collapse;
  }

  #tournament-manager-root .players-table th,
  #tournament-manager-root .players-table td {
    padding: 8px;
    border-bottom: 1px solid #ececec;
    text-align: left;
    font-size: 0.95rem;
  }

  #tournament-manager-root .players-table tbody tr:hover {
    background: #f7faff;
  }

  #tournament-manager-root .players-table .index-cell {
    width: 48px;
    color: #888;
  }

  #tournament-manager-root .players-actions {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    margin-top: 12px;
  }

  #tournament-manager-root button {
    border-radius: 8px;
    border: 1px solid transparent;
    padding: 8px 14px;
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s ease, color 0.2s ease;
  }

  #tournament-manager-root button.primary {
    background: #2563eb;
    color: #fff;
  }

  #tournament-manager-root button.secondary {
    background: #eff3ff;
    color: #1d4ed8;
    border-color: #c7d2fe;
  }

  #tournament-manager-root button.ghost {
    background: transparent;
    color: #ef4444;
    border-color: #fca5a5;
  }

  #tournament-manager-root button:disabled {
    opacity: 0.55;
    cursor: not-allowed;
  }

  #tournament-manager-root .bracket-wrapper {
    display: flex;
    flex-direction: column;
    gap: 24px;
  }

  #tournament-manager-root .bracket-section {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  #tournament-manager-root .bracket-section h3 {
    margin: 0;
    font-size: 1.1rem;
  }

  #tournament-manager-root .rounds {
    display: flex;
    gap: 16px;
    overflow-x: auto;
    padding-bottom: 8px;
  }

  #tournament-manager-root .round {
    min-width: 200px;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  #tournament-manager-root .round-title {
    font-size: 0.85rem;
    text-transform: uppercase;
    color: #666;
    letter-spacing: 0.06em;
  }

  #tournament-manager-root .match {
    border: 1px solid #d7d7d7;
    border-radius: 10px;
    background: #fff;
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    position: relative;
  }

  #tournament-manager-root .match.completed {
    border-color: #2563eb;
    box-shadow: 0 0 0 1px #a3bffa;
  }

  #tournament-manager-root .match-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.8rem;
    color: #777;
  }

  #tournament-manager-root .player-row {
    display: grid;
    grid-template-columns: 1fr 52px;
    align-items: center;
    gap: 6px;
    padding: 6px 8px;
    border-radius: 6px;
    background: #f9fafb;
  }

  #tournament-manager-root .player-row.active {
    background: #2563eb;
    color: #fff;
  }

  #tournament-manager-root .player-row span {
    display: block;
  }

  #tournament-manager-root .player-name {
    font-weight: 600;
  }

  #tournament-manager-root .player-meta,
  #tournament-manager-root .player-origin {
    font-size: 0.75rem;
    color: inherit;
    opacity: 0.86;
  }

  #tournament-manager-root .player-origin {
    font-style: italic;
  }

  #tournament-manager-root .match-meta {
    font-size: 0.75rem;
    color: #4b5563;
    border-top: 1px solid #e5e7eb;
    padding-top: 6px;
    margin-top: -2px;
  }

  #tournament-manager-root .score-input {
    width: 100%;
    border-radius: 6px;
    border: 1px solid #cbd5f5;
    padding: 4px 6px;
    text-align: center;
    font-weight: 600;
  }

  #tournament-manager-root .match-actions {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
  }

  #tournament-manager-root .empty-state {
    padding: 24px;
    text-align: center;
    color: #777;
    border: 1px dashed #cbd5f5;
    border-radius: 12px;
    background: #f8fbff;
  }

  #tournament-manager-root .radio-group {
    display: flex;
    gap: 16px;
  }

  #tournament-manager-root .radio-option {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.95rem;
  }

  #tournament-manager-root .toast {
    position: fixed;
    bottom: 24px;
    right: 24px;
    background: #2563eb;
    color: #fff;
    padding: 12px 18px;
    border-radius: 10px;
    box-shadow: 0 10px 24px rgba(37, 99, 235, 0.25);
    opacity: 0;
    pointer-events: none;
    transform: translateY(10px);
    transition: opacity 0.2s ease, transform 0.2s ease;
  }

  #tournament-manager-root .toast.show {
    opacity: 1;
    transform: translateY(0);
  }

  @media (max-width: 640px) {
    #tournament-manager-root {
      background: #f8fafc;
    }

    #tournament-manager-root .app {
      padding: 16px 14px 32px;
      gap: 18px;
    }

    #tournament-manager-root .intro-overlay {
      align-items: flex-start;
      padding: 12px;
    }

    #tournament-manager-root header h1 {
      font-size: 1.45rem;
    }

    #tournament-manager-root .panel {
      padding: 14px;
    }

    #tournament-manager-root .intro-card {
      width: 100%;
      max-height: 100%;
      border-radius: 0;
      padding: 20px 18px;
      overflow-y: auto;
    }

    #tournament-manager-root .intro-grid {
      grid-template-columns: 1fr;
    }

    #tournament-manager-root .intro-player-list {
      max-height: 220px;
    }

    #tournament-manager-root .intro-player-row {
      grid-template-columns: 1fr;
      gap: 10px;
    }

    #tournament-manager-root .intro-player-row .paid-checkbox {
      justify-content: flex-start;
    }

    #tournament-manager-root .intro-actions {
      flex-direction: column;
      align-items: stretch;
    }

    #tournament-manager-root .intro-actions button {
      width: 100%;
    }

    #tournament-manager-root .inputs {
      grid-template-columns: 1fr;
      gap: 10px;
    }

    #tournament-manager-root table.players-table {
      min-width: 520px;
    }

    #tournament-manager-root .players-table {
      display: block;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    #tournament-manager-root .players-actions {
      flex-direction: column;
      align-items: stretch;
    }

    #tournament-manager-root .players-actions button {
      width: 100%;
    }

    #tournament-manager-root .rounds {
      gap: 12px;
    }

    #tournament-manager-root .round {
      min-width: 160px;
    }

    #tournament-manager-root .match {
      padding: 10px;
    }

    #tournament-manager-root .match-actions {
      flex-direction: column-reverse;
      align-items: stretch;
    }

    #tournament-manager-root .match-actions button {
      width: 100%;
    }
  }

  @media (max-width: 720px) {
    #tournament-manager-root .round {
      min-width: 180px;
    }

    #tournament-manager-root .player-row {
      grid-template-columns: 1fr 44px;
    }
  }
</style>

<div id="tournament-manager-root" data-turbo="false">
  <div id="intro-overlay" class="intro-overlay">
    <form id="intro-form" class="intro-card">
      <div class="intro-header">
        <h2>Quick Tournament Setup</h2>
        <p class="note-text">Enter the basics and optionally randomize teams before building your bracket.</p>
      </div>

      <div class="intro-grid">
        <div class="field">
          <label>Entry Type</label>
          <div class="radio-group">
            <label class="radio-option">
              <input type="radio" name="intro-entry-format" value="singles" checked>
              <span>Singles</span>
            </label>
            <label class="radio-option">
              <input type="radio" name="intro-entry-format" value="doubles">
              <span>Doubles</span>
            </label>
          </div>
        </div>

        <div class="field">
          <label>Elimination Type</label>
          <div class="radio-group">
            <label class="radio-option">
              <input type="radio" name="intro-elimination" value="single" checked>
              <span>Single elimination</span>
            </label>
            <label class="radio-option">
              <input type="radio" name="intro-elimination" value="double">
              <span>Double elimination</span>
            </label>
          </div>
        </div>

        <div class="field">
          <label for="intro-entry-fee">Entry fee</label>
          <input type="number" id="intro-entry-fee" name="intro-entry-fee" placeholder="0" min="0" step="0.01">
        </div>
      </div>

      <div class="field">
        <label>Players</label>
        <div id="intro-player-list" class="intro-player-list"></div>
        <button type="button" class="secondary" id="intro-add-player">Add player</button>
        <p class="note-text">Add players in any order. We will try to pair A and B levels for doubles.</p>
      </div>

      <div class="intro-actions">
        <button type="button" class="ghost" id="intro-skip">Skip, I will set it up manually</button>
        <button type="submit" class="primary">Create random draw</button>
      </div>
    </form>
  </div>

  <main class="app">
    <header>
      <h1>Tournament Manager</h1>
      <p>Enter players, decide on single or double elimination, then build and manage the bracket directly in your browser.</p>
    </header>

    <section class="panel">
      <h2>Participants</h2>
      <div class="inputs">
        <div class="field">
          <label for="entry-format">Entry Type</label>
          <div class="radio-group" id="entry-format">
            <label class="radio-option">
              <input type="radio" name="entry-format" value="singles" checked>
              <span>Singles</span>
            </label>
            <label class="radio-option">
              <input type="radio" name="entry-format" value="doubles">
              <span>Doubles</span>
            </label>
          </div>
        </div>
        <div class="field">
          <label for="tournament-type">Elimination Type</label>
          <div class="radio-group" id="tournament-type">
            <label class="radio-option">
              <input type="radio" name="elimination" value="single" checked>
              <span>Single elimination</span>
            </label>
            <label class="radio-option">
              <input type="radio" name="elimination" value="double">
              <span>Double elimination</span>
            </label>
          </div>
        </div>
      </div>

      <table class="players-table">
        <thead>
          <tr>
            <th>#</th>
            <th id="name-column-label">Player</th>
            <th>Seed (optional)</th>
            <th></th>
          </tr>
        </thead>
        <tbody id="player-rows"></tbody>
      </table>

      <div class="players-actions">
        <button type="button" class="secondary" id="add-player">Add player</button>
        <button type="button" class="ghost" id="clear-players">Clear all</button>
        <button type="button" class="primary" id="create-draw">Create draw</button>
      </div>
    </section>

    <section class="panel">
      <h2>Bracket</h2>
      <div id="bracket-container" class="bracket-wrapper">
        <div class="empty-state">Add at least two players and click "Create draw" to see the bracket.</div>
      </div>
    </section>
  </main>

  <div id="toast" class="toast"></div>
</div>

<script>
  (function () {
    const root = document.getElementById('tournament-manager-root');
    if (!root || root.dataset.initialized === 'true') return;
    root.dataset.initialized = 'true';

    const MAX_PLAYERS = 128;
    const playerTableBody = document.getElementById('player-rows');
    const addPlayerBtn = document.getElementById('add-player');
    const clearPlayersBtn = document.getElementById('clear-players');
    const createDrawBtn = document.getElementById('create-draw');
    const bracketContainer = document.getElementById('bracket-container');
    const toastEl = document.getElementById('toast');
    const entryFormatInputs = document.querySelectorAll('input[name="entry-format"]');
    const nameColumnLabel = document.getElementById('name-column-label');
    const introOverlay = document.getElementById('intro-overlay');
    const introForm = document.getElementById('intro-form');
    const introPlayerList = document.getElementById('intro-player-list');
    const introAddPlayerBtn = document.getElementById('intro-add-player');
    const introSkipBtn = document.getElementById('intro-skip');
    const introEntryFeeInput = document.getElementById('intro-entry-fee');

    let playerIdCounter = 0;
    let layoutScheduled = false;

    const state = {
      tournament: null,
      matches: new Map(),
      entryFormat: 'singles',
      entryFee: 0,
    };

    function showToast(message) {
      if (!toastEl) return;
      toastEl.textContent = message;
      toastEl.classList.add('show');
      setTimeout(() => toastEl.classList.remove('show'), 2600);
    }

    function createIntroPlayerRow(preset = {}) {
      if (!introPlayerList) return;
      const row = document.createElement('div');
      row.className = 'intro-player-row';

      const nameInput = document.createElement('input');
      nameInput.type = 'text';
      nameInput.placeholder = 'Player name';
      nameInput.value = preset.name || '';

      const levelSelect = document.createElement('select');
      const optionPlaceholder = document.createElement('option');
      optionPlaceholder.value = '';
      optionPlaceholder.textContent = 'Level';
      const optionA = document.createElement('option');
      optionA.value = 'A';
      optionA.textContent = 'A';
      const optionB = document.createElement('option');
      optionB.value = 'B';
      optionB.textContent = 'B';
      levelSelect.appendChild(optionPlaceholder);
      levelSelect.appendChild(optionA);
      levelSelect.appendChild(optionB);
      if (preset.level) {
        levelSelect.value = preset.level;
      }

      const paidWrapper = document.createElement('label');
      paidWrapper.className = 'paid-checkbox';
      const paidInput = document.createElement('input');
      paidInput.type = 'checkbox';
      paidInput.checked = !!preset.paid;
      const paidText = document.createElement('span');
      paidText.textContent = 'Paid';
      paidWrapper.appendChild(paidInput);
      paidWrapper.appendChild(paidText);

      row.appendChild(nameInput);
      row.appendChild(levelSelect);
      row.appendChild(paidWrapper);

      introPlayerList.appendChild(row);
      setTimeout(() => nameInput.focus(), 0);
    }

    function readIntroPlayers() {
      if (!introPlayerList) return [];
      const rows = Array.from(introPlayerList.querySelectorAll('.intro-player-row'));
      return rows.map(row => {
        const nameInput = row.querySelector('input[type="text"]');
        const levelSelect = row.querySelector('select');
        const paidInput = row.querySelector('input[type="checkbox"]');
        return {
          name: nameInput ? nameInput.value.trim() : '',
          level: levelSelect ? (levelSelect.value || '') : '',
          paid: paidInput ? paidInput.checked : false,
        };
      }).filter(player => player.name);
    }

    function shuffleArray(array) {
      const copy = array.slice();
      for (let i = copy.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
      }
      return copy;
    }

    function buildEntriesFromIntro(format, players) {
      if (format === 'singles') {
        const shuffled = shuffleArray(players);
        return shuffled.map(player => ({
          primary: player.name,
          partner: null,
          meta: player,
        }));
      }

      if (players.length < 2 || players.length % 2 !== 0) {
        throw new Error('Doubles requires an even number of players.');
      }

      const withLevels = players.map(player => ({
        ...player,
        level: (player.level || 'B').toUpperCase() === 'A' ? 'A' : 'B',
      }));

      const groupA = shuffleArray(withLevels.filter(p => p.level === 'A'));
      const groupB = shuffleArray(withLevels.filter(p => p.level !== 'A'));

      const teams = [];

      while (groupA.length > 0 && groupB.length > 0) {
        const aPlayer = groupA.pop();
        const bPlayer = groupB.pop();
        teams.push([aPlayer, bPlayer]);
      }

      const remaining = shuffleArray(groupA.concat(groupB));
      if (remaining.length % 2 !== 0) {
        throw new Error('Unpaired player remaining; add one more player to continue.');
      }
      for (let i = 0; i < remaining.length; i += 2) {
        teams.push([remaining[i], remaining[i + 1]]);
      }

      const shuffledTeams = shuffleArray(teams);
      return shuffledTeams.map(pair => ({
        primary: pair[0].name,
        partner: pair[1] ? pair[1].name : '',
        meta: pair,
      }));
    }

    function applyIntroConfiguration(config) {
      const { format, elimination, entryFee, entries } = config;
      state.entryFee = entryFee;

      entryFormatInputs.forEach(input => {
        input.checked = input.value === format;
      });
      state.entryFormat = format;
      applyFormatToRows(format);

      const eliminationInputs = document.querySelectorAll('input[name="elimination"]');
      eliminationInputs.forEach(input => {
        input.checked = input.value === elimination;
      });

      playerTableBody.innerHTML = '';
      entries.forEach(entry => {
        createPlayerRow(entry.primary, '', entry.partner || '');
      });
      applyFormatToRows(state.entryFormat);
      handleFormatChange();
      showToast('Players added. Adjust seeds if needed.');
    }

    function hideIntroOverlay() {
      if (introOverlay) {
        introOverlay.classList.add('hidden');
      }
    }

    function handleIntroSubmit(event) {
      event.preventDefault();
      const format = (introForm && new FormData(introForm).get('intro-entry-format')) || 'singles';
      const elimination = (introForm && new FormData(introForm).get('intro-elimination')) || 'single';
      const entryFeeValue = introEntryFeeInput && introEntryFeeInput.value ? parseFloat(introEntryFeeInput.value, 10) : 0;
      const players = readIntroPlayers();
      if (players.length < 2) {
        showToast('Add at least two players to continue.');
        return;
      }
      if (format === 'doubles' && players.length % 2 !== 0) {
        showToast('Add one more player to form complete teams for doubles.');
        return;
      }

      try {
        const entries = buildEntriesFromIntro(format, players);
        applyIntroConfiguration({
          format,
          elimination,
          entryFee: Number.isFinite(entryFeeValue) ? entryFeeValue : 0,
          entries,
        });
        hideIntroOverlay();
      } catch (err) {
        showToast(err.message || 'Unable to build teams.');
      }
    }

    function scheduleBracketLayout() {
      if (typeof window === 'undefined') return;
      if (layoutScheduled) return;
      layoutScheduled = true;
      window.requestAnimationFrame(() => {
        layoutScheduled = false;
        const wrappers = bracketContainer.querySelectorAll('.rounds');
        wrappers.forEach(wrapper => applyBracketSpacing(wrapper));
      });
    }

    function getEntryFormat() {
      const chosen = document.querySelector('input[name="entry-format"]:checked');
      return chosen ? chosen.value : 'singles';
    }

    function configureRowForFormat(row, format) {
      if (!row) return;
      row.classList.toggle('is-doubles', format === 'doubles');
      const primaryInput = row.querySelector('.player-name-input');
      const partnerInput = row.querySelector('.player-partner-input');
      if (primaryInput) {
        primaryInput.placeholder = format === 'doubles' ? 'Player 1 name' : 'Player name';
      }
      if (partnerInput) {
        partnerInput.placeholder = 'Player 2 name';
        partnerInput.disabled = format !== 'doubles';
        if (format !== 'doubles') {
          partnerInput.value = '';
        }
      }
    }

    function applyFormatToRows(format) {
      Array.from(playerTableBody.children).forEach(row => configureRowForFormat(row, format));
      if (nameColumnLabel) {
        nameColumnLabel.textContent = format === 'doubles' ? 'Team (two players)' : 'Player';
      }
    }

    function handleFormatChange() {
      state.entryFormat = getEntryFormat();
      applyFormatToRows(state.entryFormat);
    }

    function createPlayerRow(name = '', seed = '', partner = '') {
      if (playerTableBody.children.length >= MAX_PLAYERS) {
        showToast('Maximum of 128 players reached.');
        return;
      }

      const row = document.createElement('tr');

      const indexCell = document.createElement('td');
      indexCell.className = 'index-cell';

      const nameCell = document.createElement('td');
      const nameWrapper = document.createElement('div');
      nameWrapper.className = 'name-inputs';

      const nameInput = document.createElement('input');
      nameInput.type = 'text';
      nameInput.placeholder = 'Player name';
      nameInput.value = name;
      nameInput.className = 'player-name-input';

      const partnerInput = document.createElement('input');
      partnerInput.type = 'text';
      partnerInput.placeholder = 'Player 2 name';
      partnerInput.value = partner;
      partnerInput.className = 'player-partner-input';

      nameWrapper.appendChild(nameInput);
      nameWrapper.appendChild(partnerInput);

      const seedCell = document.createElement('td');
      const seedInput = document.createElement('input');
      seedInput.type = 'number';
      seedInput.placeholder = 'Seed';
      seedInput.min = '1';
      seedInput.value = seed;
      seedInput.className = 'player-seed-input';

      const removeCell = document.createElement('td');
      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.textContent = 'Remove';
      removeBtn.className = 'ghost';
      removeBtn.addEventListener('click', () => {
        row.remove();
        refreshRowIndices();
      });
      removeCell.appendChild(removeBtn);

      nameCell.appendChild(nameWrapper);
      seedCell.appendChild(seedInput);

      row.appendChild(indexCell);
      row.appendChild(nameCell);
      row.appendChild(seedCell);
      row.appendChild(removeCell);

      playerTableBody.appendChild(row);
      configureRowForFormat(row, state.entryFormat);
      refreshRowIndices();
    }

    function refreshRowIndices() {
      Array.from(playerTableBody.children).forEach((row, index) => {
        const cell = row.querySelector('.index-cell');
        if (cell) {
          cell.textContent = index + 1;
        }
      });
    }

    function clearPlayers() {
      playerTableBody.innerHTML = '';
      for (let i = 0; i < 8; i += 1) {
        createPlayerRow();
      }
      applyFormatToRows(state.entryFormat);
    }

    function readPlayersFromTable() {
      const seenNames = new Set();
      const seenSeeds = new Map();
      const players = [];
      const format = state.entryFormat || getEntryFormat();

      Array.from(playerTableBody.children).forEach((row, index) => {
        const nameInput = row.querySelector('.player-name-input');
        const partnerInput = row.querySelector('.player-partner-input');
        const seedInput = row.querySelector('.player-seed-input');
        if (!nameInput) return;

        const primaryName = nameInput.value.trim();
        if (!primaryName) return;

        let displayName = primaryName;
        let partnerName = '';
        let members = null;

        if (format === 'doubles') {
          if (!partnerInput) {
            throw new Error('Encountered a team row without a second player field.');
          }
          partnerName = partnerInput.value.trim();
          if (!partnerName) {
            throw new Error('Doubles entries require two players. Missing second name for "' + primaryName + '".');
          }
          members = [primaryName, partnerName];
          displayName = primaryName + ' / ' + partnerName;
        }

        const nameKey = displayName.toLowerCase();
        if (seenNames.has(nameKey)) {
          throw new Error('Duplicate entry: "' + displayName + '".');
        }
        seenNames.add(nameKey);

        const seedStr = seedInput && seedInput.value ? seedInput.value.trim() : '';
        let seed = null;
        if (seedStr) {
          const parsed = parseInt(seedStr, 10);
          if (Number.isNaN(parsed) || parsed < 1) {
            throw new Error('Seeds must be positive integers. Invalid seed for ' + displayName + '.');
          }
          if (seenSeeds.has(parsed)) {
            throw new Error('Duplicate seed value: ' + parsed + '.');
          }
          seenSeeds.set(parsed, true);
          seed = parsed;
        }

        playerIdCounter += 1;
        players.push({
          id: 'P' + playerIdCounter,
          name: displayName,
          seed,
          order: index,
          losses: 0,
          members,
          primaryName,
          partnerName: partnerName || null,
        });
      });

      return players;
    }

    function sortPlayersForSeeding(players) {
      const seededPlayers = players.filter(p => Number.isInteger(p.seed))
        .sort((a, b) => a.seed - b.seed || a.order - b.order);

      const usedSeeds = new Set(seededPlayers.map(p => p.seed));
      let nextSeedCandidate = 1;

      function nextAvailableSeed() {
        while (usedSeeds.has(nextSeedCandidate)) {
          nextSeedCandidate += 1;
        }
        const chosen = nextSeedCandidate;
        usedSeeds.add(chosen);
        nextSeedCandidate += 1;
        return chosen;
      }

      const seeded = seededPlayers.map(player => ({
        ...player,
        seedValue: player.seed,
        displaySeed: player.seed,
      }));

      const unseeded = players.filter(p => !Number.isInteger(p.seed))
        .map(player => {
          const seedValue = nextAvailableSeed();
          return {
            ...player,
            seedValue,
            displaySeed: null,
          };
        });

      return seeded.concat(unseeded)
        .sort((a, b) => a.seedValue - b.seedValue || a.order - b.order);
    }

    function nextPowerOfTwo(value) {
      return Math.pow(2, Math.ceil(Math.log2(Math.max(2, value))));
    }

    function generateSeedOrder(size) {
      if (size === 1) return [1];
      const prev = generateSeedOrder(size / 2);
      const result = [];
      for (let i = 0; i < prev.length; i += 1) {
        result.push(prev[i]);
        result.push(size + 1 - prev[i]);
      }
      return result;
    }

    function createMatch(params) {
      return {
        id: params.id,
        bracket: params.bracket,
        roundIndex: params.roundIndex,
        matchIndex: params.matchIndex,
        roundName: params.roundName,
        players: [null, null],
        scores: [null, null],
        completed: false,
        nextMatchId: null,
        nextSlot: null,
        loserDest: null,
        propagated: {
          winner: null,
          loser: null,
        },
        element: null,
        sources: [null, null],
        sourceMeta: [null, null],
        slotAnnotations: ['', ''],
        loserDestLabel: '',
      };
    }

    function describeRound(roundIndex, totalRounds, bracket) {
      if (roundIndex === totalRounds - 1) {
        return bracket === 'winners' ? 'Final' : 'Losers Final';
      }
      if (roundIndex === totalRounds - 2 && totalRounds > 2) {
        return bracket === 'winners' ? 'Semifinal' : 'Penultimate';
      }
      return (bracket === 'winners' ? 'Round ' : 'Losers Round ') + (roundIndex + 1);
    }

    function buildWinnersBracket(sortedPlayers, bracketSize) {
      const rounds = [];
      const matchesById = new Map();
      const seedOrder = generateSeedOrder(bracketSize);
      const positionBySeed = new Map();
      seedOrder.forEach((seedNumber, index) => {
        positionBySeed.set(seedNumber, index);
      });
      const initialSlots = new Array(bracketSize).fill(null);

      sortedPlayers.forEach(player => {
        const slotIndex = positionBySeed.get(player.seedValue);
        if (typeof slotIndex !== 'number') {
          return;
        }
        initialSlots[slotIndex] = {
          ...player,
          displaySeed: player.displaySeed ?? (Number.isInteger(player.seed) ? player.seed : null),
          seedValue: player.seedValue,
          losses: player.losses,
        };
      });

      for (let i = 0; i < initialSlots.length; i += 1) {
        if (!initialSlots[i]) {
          initialSlots[i] = {
            id: 'BYE-' + (i + 1),
            name: 'BYE',
            isBye: true,
            seedValue: Infinity,
            displaySeed: null,
            losses: 0,
          };
        }
      }

      let matchesInRound = bracketSize / 2;
      let slotCursor = 0;
      let roundIndex = 0;
      const totalRounds = Math.log2(bracketSize);

      while (matchesInRound >= 1) {
        const roundMatches = [];
        for (let matchIdx = 0; matchIdx < matchesInRound; matchIdx += 1) {
          const matchId = 'W' + (roundIndex + 1) + '-' + (matchIdx + 1);
          const match = createMatch({
            id: matchId,
            bracket: 'winners',
            roundIndex,
            matchIndex: matchIdx,
            roundName: describeRound(roundIndex, totalRounds, 'winners'),
          });
          match.loserDestLabel = 'Loser eliminated';

          if (roundIndex === 0) {
            match.players[0] = initialSlots[slotCursor] || null;
            match.players[1] = initialSlots[slotCursor + 1] || null;
            slotCursor += 2;
          }

          roundMatches.push(match);
          matchesById.set(match.id, match);
        }
        rounds.push(roundMatches);
        matchesInRound /= 2;
        roundIndex += 1;
      }

      for (let r = 0; r < rounds.length - 1; r += 1) {
        const currentRound = rounds[r];
        const nextRound = rounds[r + 1];
        currentRound.forEach((match, idx) => {
          const targetIndex = Math.floor(idx / 2);
          const nextMatch = nextRound[targetIndex];
          match.nextMatchId = nextMatch.id;
          match.nextSlot = idx % 2;
          nextMatch.sources[match.nextSlot] = match.id;
          nextMatch.sourceMeta[match.nextSlot] = { type: 'winner', from: match.id };
          nextMatch.slotAnnotations[match.nextSlot] = 'Winner of ' + match.id;
        });
      }

      return { rounds, matchesById };
    }

    function buildGrandFinal(matchesById) {
      const finalMatch = createMatch({
        id: 'GF-1',
        bracket: 'final',
        roundIndex: 0,
        matchIndex: 0,
        roundName: 'Grand Final',
      });
      finalMatch.loserDestLabel = 'Loser eliminated';
      matchesById.set(finalMatch.id, finalMatch);
      return finalMatch;
    }

    function buildLosersBracket(winnersRounds, matchesById, grandFinal) {
      const losersRounds = [];
      const winnersRoundsCount = winnersRounds.length;
      if (winnersRoundsCount <= 1) {
        return { rounds: losersRounds };
      }

      const totalLoserRounds = Math.max(0, (winnersRoundsCount - 1) * 2);

      function createLosersRound(matchCount) {
        const roundIndex = losersRounds.length;
        const roundMatches = [];
        for (let idx = 0; idx < matchCount; idx += 1) {
          const id = 'L' + (roundIndex + 1) + '-' + (idx + 1);
          const match = createMatch({
            id,
            bracket: 'losers',
            roundIndex,
            matchIndex: idx,
            roundName: describeRound(roundIndex, totalLoserRounds, 'losers'),
          });
          match.loserDestLabel = 'Loser eliminated';
          matchesById.set(id, match);
          roundMatches.push(match);
        }
        losersRounds.push(roundMatches);
        return roundMatches;
      }

      const firstWinnersRound = winnersRounds[0];
      const firstRoundMatchCount = Math.max(0, Math.floor(firstWinnersRound.length / 2));
      let currentRound = [];
      if (firstRoundMatchCount > 0) {
        currentRound = createLosersRound(firstRoundMatchCount);
        for (let i = 0; i < firstWinnersRound.length; i += 1) {
          const targetIndex = Math.floor(i / 2);
          const targetMatch = currentRound[targetIndex];
          if (!targetMatch) continue;
          const sourceMatch = firstWinnersRound[i];
          const slot = i % 2;
          if (sourceMatch) {
            sourceMatch.loserDest = { matchId: targetMatch.id, slot };
            sourceMatch.loserDestLabel = 'Loser → ' + targetMatch.id;
            targetMatch.sources[slot] = sourceMatch.id;
            targetMatch.sourceMeta[slot] = { type: 'loser', from: sourceMatch.id };
            targetMatch.slotAnnotations[slot] = 'Loser of ' + sourceMatch.id;
          }
        }
      }

      for (let round = 1; round < winnersRoundsCount; round += 1) {
        const winnersRound = winnersRounds[round];
        const incomingCount = winnersRound.length;
        if (incomingCount === 0) continue;

        const incomingRound = createLosersRound(incomingCount);
        const flipThisRound = (round % 2 === 1);
        for (let idx = 0; idx < incomingCount; idx += 1) {
          const targetIndex = flipThisRound ? (incomingRound.length - 1 - idx) : idx;
          const targetMatch = incomingRound[targetIndex];
          if (!targetMatch) continue;

          const previousMatch = currentRound[targetIndex];
          if (previousMatch) {
            previousMatch.nextMatchId = targetMatch.id;
            previousMatch.nextSlot = 0;
            targetMatch.sources[0] = previousMatch.id;
            targetMatch.sourceMeta[0] = { type: 'winner', from: previousMatch.id };
            targetMatch.slotAnnotations[0] = 'Winner of ' + previousMatch.id;
          }

          const winnersSource = winnersRound[idx];
          if (winnersSource) {
            winnersSource.loserDest = { matchId: targetMatch.id, slot: 1 };
            winnersSource.loserDestLabel = 'Loser → ' + targetMatch.id;
            targetMatch.sources[1] = winnersSource.id;
            targetMatch.sourceMeta[1] = { type: 'loser', from: winnersSource.id };
            targetMatch.slotAnnotations[1] = 'Loser of ' + winnersSource.id;
          }
        }

        currentRound = incomingRound;

        const consolidationCount = Math.floor(currentRound.length / 2);
        if (consolidationCount > 0) {
          const consolidationRound = createLosersRound(consolidationCount);
          for (let pair = 0; pair < consolidationCount; pair += 1) {
            const flipConsolidation = (round % 2 === 1);
            const targetIndex = flipConsolidation ? (consolidationRound.length - 1 - pair) : pair;
            const targetMatch = consolidationRound[targetIndex];
            if (!targetMatch) continue;
            const baseIndexA = flipConsolidation ? (currentRound.length - 1 - (pair * 2)) : (pair * 2);
            const baseIndexB = flipConsolidation ? (currentRound.length - 2 - (pair * 2)) : (pair * 2 + 1);
            const sourceA = currentRound[baseIndexA];
            const sourceB = currentRound[baseIndexB];
            if (sourceA) {
              sourceA.nextMatchId = targetMatch.id;
              sourceA.nextSlot = 0;
              targetMatch.sources[0] = sourceA.id;
              targetMatch.sourceMeta[0] = { type: 'winner', from: sourceA.id };
              targetMatch.slotAnnotations[0] = 'Winner of ' + sourceA.id;
            }
            if (sourceB) {
              sourceB.nextMatchId = targetMatch.id;
              sourceB.nextSlot = 1;
              targetMatch.sources[1] = sourceB.id;
              targetMatch.sourceMeta[1] = { type: 'winner', from: sourceB.id };
              targetMatch.slotAnnotations[1] = 'Winner of ' + sourceB.id;
            }
          }
          currentRound = consolidationRound;
        }
      }

      if (grandFinal && currentRound.length > 0) {
        currentRound.forEach(match => {
          match.nextMatchId = grandFinal.id;
          match.nextSlot = 1;
          grandFinal.sources[1] = match.id;
          grandFinal.sourceMeta[1] = { type: 'winner', from: match.id };
          grandFinal.slotAnnotations[1] = 'Winner of ' + match.id;
        });
      }

      return { rounds: losersRounds };
    }

    function renderTournament(tournament) {
      state.matches = tournament.matchMap;
      bracketContainer.innerHTML = '';

      const winnersSection = document.createElement('div');
      winnersSection.className = 'bracket-section';
      const winnersTitle = document.createElement('h3');
      winnersTitle.textContent = 'Winners Bracket';
      winnersSection.appendChild(winnersTitle);
      const winnersRoundsEl = renderRoundColumns(tournament.winners.rounds);
      winnersSection.appendChild(winnersRoundsEl);
      bracketContainer.appendChild(winnersSection);

      let losersRoundsEl = null;
      if (tournament.type === 'double' && tournament.losers.rounds.length > 0) {
        const losersSection = document.createElement('div');
        losersSection.className = 'bracket-section';
        const losersTitle = document.createElement('h3');
        losersTitle.textContent = 'Losers Bracket';
        losersSection.appendChild(losersTitle);
        losersRoundsEl = renderRoundColumns(tournament.losers.rounds);
        losersSection.appendChild(losersRoundsEl);
        bracketContainer.appendChild(losersSection);
      }

      let finalsRoundsEl = null;
      if (tournament.type === 'double') {
        const finalsSection = document.createElement('div');
        finalsSection.className = 'bracket-section';
        const finalsTitle = document.createElement('h3');
        finalsTitle.textContent = 'Finals';
        finalsSection.appendChild(finalsTitle);
        finalsRoundsEl = renderRoundColumns([[tournament.finalMatch]]);
        finalsSection.appendChild(finalsRoundsEl);
        bracketContainer.appendChild(finalsSection);
      }

      state.matches.forEach(match => {
        if (match.bracket === 'winners' || match.bracket === 'losers' || match.bracket === 'final') {
          updateMatchDisplay(match);
          attemptAutoAdvance(match);
        }
      });

      scheduleBracketLayout();
    }

    function renderRoundColumns(rounds) {
      const roundsWrapper = document.createElement('div');
      roundsWrapper.className = 'rounds';
      rounds.forEach(roundMatches => {
        const column = document.createElement('div');
        column.className = 'round';
        if (roundMatches.length > 0) {
          const title = document.createElement('div');
          title.className = 'round-title';
          title.textContent = roundMatches[0].roundName;
          column.appendChild(title);
        }
        roundMatches.forEach(match => {
          const matchEl = createMatchElement(match);
          match.element = matchEl;
          column.appendChild(matchEl);
          updateMatchMeta(match);
        });
        roundsWrapper.appendChild(column);
      });
      return roundsWrapper;
    }

    function resetRoundSpacing(roundsWrapper) {
      if (!roundsWrapper) return;
      const matches = roundsWrapper.querySelectorAll('.match');
      matches.forEach(matchEl => {
        matchEl.style.marginTop = '0px';
      });
    }

    function applyBracketSpacing(roundsWrapper) {
      if (!roundsWrapper || typeof window === 'undefined') return;
      resetRoundSpacing(roundsWrapper);
      const columns = Array.from(roundsWrapper.querySelectorAll('.round'));
      if (columns.length < 2) {
        return;
      }
      columns.forEach((column, columnIndex) => {
        if (columnIndex === 0) return;
        const matches = Array.from(column.querySelectorAll('.match'));
        matches.forEach(matchEl => {
          const matchId = matchEl.dataset.matchId;
          const match = state.matches.get(matchId);
          if (!match || !Array.isArray(match.sources)) return;
          const sourceCenters = match.sources
            .filter(Boolean)
            .map(sourceId => {
              const sourceMatch = state.matches.get(sourceId);
              if (!sourceMatch || !sourceMatch.element) return null;
              if (!roundsWrapper.contains(sourceMatch.element)) return null;
              const rect = sourceMatch.element.getBoundingClientRect();
              return rect.top + (rect.height / 2);
            })
            .filter(value => value !== null);
          if (!sourceCenters.length) return;
          const desiredCenter = sourceCenters.reduce((sum, value) => sum + value, 0) / sourceCenters.length;
          const rect = matchEl.getBoundingClientRect();
          const currentCenter = rect.top + (rect.height / 2);
          const delta = desiredCenter - currentCenter;
          matchEl.style.marginTop = delta + 'px';
        });
      });
    }

    function createMatchElement(match) {
      const container = document.createElement('div');
      container.className = 'match';
      container.dataset.matchId = match.id;

      const header = document.createElement('div');
      #tournament-manager-root header.className = 'match-header';
      #tournament-manager-root header.innerHTML = '<span>' + match.id + '</span>' + '<span>' + match.roundName + '</span>';
      container.appendChild(header);

      const metaInfo = document.createElement('div');
      metaInfo.className = 'match-meta';
      metaInfo.textContent = '';
      container.appendChild(metaInfo);

      const playerRows = [];
      const scoreInputs = [];

      for (let slot = 0; slot < 2; slot += 1) {
        const row = document.createElement('div');
        row.className = 'player-row';
        row.dataset.slot = String(slot);

        const infoWrapper = document.createElement('div');
        infoWrapper.className = 'player-row-details';
        const nameSpan = document.createElement('span');
        nameSpan.className = 'player-name';
        const metaSpan = document.createElement('span');
        metaSpan.className = 'player-meta';
        const originSpan = document.createElement('span');
        originSpan.className = 'player-origin';
        infoWrapper.appendChild(nameSpan);
        infoWrapper.appendChild(metaSpan);
        infoWrapper.appendChild(originSpan);

        const scoreInput = document.createElement('input');
        scoreInput.type = 'number';
        scoreInput.className = 'score-input';
        scoreInput.disabled = true;
        scoreInput.dataset.slot = String(slot);

        row.appendChild(infoWrapper);
        row.appendChild(scoreInput);
        container.appendChild(row);

        playerRows.push({ row, nameSpan, metaSpan, originSpan });
        scoreInputs.push(scoreInput);
      }

      match.elements = {
        container,
        playerRows,
        scoreInputs,
        metaInfo,
      };

      const actions = document.createElement('div');
      actions.className = 'match-actions';
      const completeBtn = document.createElement('button');
      completeBtn.type = 'button';
      completeBtn.textContent = 'Record result';
      completeBtn.className = 'secondary';
      completeBtn.addEventListener('click', () => handleCompleteMatch(match.id));

      const resetBtn = document.createElement('button');
      resetBtn.type = 'button';
      resetBtn.textContent = 'Reset';
      resetBtn.className = 'ghost';
      resetBtn.addEventListener('click', () => handleResetMatch(match.id));

      match.elements.completeBtn = completeBtn;
      match.elements.resetBtn = resetBtn;

      actions.appendChild(resetBtn);
      actions.appendChild(completeBtn);
      container.appendChild(actions);

      return container;
    }

    function updateMatchMeta(match) {
      if (!match || !match.elements) return;
      const { metaInfo, playerRows } = match.elements;
      if (metaInfo) {
        metaInfo.textContent = match.loserDestLabel || '';
        metaInfo.style.display = match.loserDestLabel ? 'block' : 'none';
      }
      if (playerRows) {
        playerRows.forEach((rowInfo, idx) => {
          const note = match.slotAnnotations ? match.slotAnnotations[idx] : '';
          if (rowInfo.originSpan) {
            rowInfo.originSpan.textContent = note || '';
          }
        });
      }
    }

    function updateMatchDisplay(match) {
      const element = match.element;
      if (!element || !match.elements) return;
      const { playerRows, scoreInputs, completeBtn, resetBtn } = match.elements;

      for (let slot = 0; slot < 2; slot += 1) {
        const player = match.players[slot];
        const visuals = playerRows[slot];
        const scoreInput = scoreInputs[slot];
        const nameSpan = visuals.nameSpan;
        const metaSpan = visuals.metaSpan;
        const originSpan = visuals.originSpan;

        if (player) {
          nameSpan.textContent = player.name;
          metaSpan.textContent = player.displaySeed ? ('Seed ' + player.displaySeed) : '';
          visuals.row.classList.toggle('is-bye', !!player.isBye);
          scoreInput.disabled = !!player.isBye;
          if (!player.isBye && !match.completed) {
            scoreInput.disabled = false;
          }
        } else {
          nameSpan.textContent = 'TBD';
          metaSpan.textContent = '';
          visuals.row.classList.remove('active');
          scoreInput.value = '';
          scoreInput.disabled = true;
        }

        const annotation = match.slotAnnotations ? match.slotAnnotations[slot] : '';
        originSpan.textContent = annotation || '';
      }

      if (match.completed) {
        element.classList.add('completed');
        const winnerSlot = match.winnerSlot;
        match.elements.playerRows.forEach((rowInfo, idx) => {
          rowInfo.row.classList.toggle('active', idx === winnerSlot);
          match.elements.scoreInputs[idx].disabled = true;
        });
        if (completeBtn) completeBtn.disabled = true;
      } else {
        element.classList.remove('completed');
        match.elements.playerRows.forEach(rowInfo => rowInfo.row.classList.remove('active'));
        if (completeBtn) {
          const ready = match.players[0] && match.players[1] && !match.players[0].isBye && !match.players[1].isBye;
          completeBtn.disabled = !ready;
        }
        if (resetBtn) {
          const hasPlayers = match.players[0] || match.players[1];
          resetBtn.disabled = !hasPlayers;
        }
      }

      updateMatchMeta(match);
      scheduleBracketLayout();
    }

    function attemptAutoAdvance(match) {
      if (match.completed) return;
      const players = match.players;
      if (!players[0] || !players[1]) return;
      const byeZero = players[0] && players[0].isBye;
      const byeOne = players[1] && players[1].isBye;
      if (byeZero && byeOne) return;
      if (byeZero || byeOne) {
        const winnerSlot = byeZero ? 1 : 0;
        const scores = winnerSlot === 0 ? [1, 0] : [0, 1];
        finalizeMatch(match, winnerSlot, scores, true);
      }
    }

    function finalizeMatch(match, winnerSlot, scores, auto = false) {
      if (!clearMatchOutcome(match)) {
        return;
      }

      const loserSlot = winnerSlot === 0 ? 1 : 0;
      const winner = match.players[winnerSlot];
      const loser = match.players[loserSlot];

      match.completed = true;
      match.winnerSlot = winnerSlot;
      match.scores = scores.slice();

      const inputs = match.elements && match.elements.scoreInputs;
      if (inputs) {
        inputs[0].value = scores[0] ?? '';
        inputs[1].value = scores[1] ?? '';
      }

      updateMatchDisplay(match);

      if (winner && match.nextMatchId) {
        const nextMatch = state.matches.get(match.nextMatchId);
        if (nextMatch) {
          placePlayerInMatch(nextMatch, match.nextSlot, { ...winner }, {
            sourceMatchId: match.id,
            isWinner: true,
          });
          match.propagated.winner = {
            matchId: nextMatch.id,
            slot: match.nextSlot,
          };
        }
      }

      if (loser) {
        if (!loser.isBye) {
          loser.losses = (loser.losses || 0) + 1;
        }

        if (state.tournament.type === 'double' && match.bracket === 'winners') {
          const loserClone = { ...loser };
          if (match.loserDest) {
            const loserMatch = state.matches.get(match.loserDest.matchId);
            if (loserMatch) {
              placePlayerInMatch(loserMatch, match.loserDest.slot, loserClone, {
                sourceMatchId: match.id,
                isWinner: false,
              });
              match.propagated.loser = {
                matchId: loserMatch.id,
                slot: match.loserDest.slot,
              };
            }
          } else if (state.tournament.finalMatch) {
            placePlayerInMatch(state.tournament.finalMatch, 1, loserClone, {
              sourceMatchId: match.id,
              isWinner: false,
            });
            match.propagated.loser = {
              matchId: state.tournament.finalMatch.id,
              slot: 1,
            };
          }
        }
      }

      if (!auto) {
        showToast('Result saved for ' + match.id + '.');
      }
    }

    function clearMatchOutcome(match) {
      if (!match.completed) {
        return true;
      }

      const winnerDest = match.propagated.winner;
      if (winnerDest) {
        const targetMatch = state.matches.get(winnerDest.matchId);
        if (targetMatch && targetMatch.completed) {
          showToast('Cannot change this result because downstream matches are already decided.');
          return false;
        }
        if (targetMatch) {
          targetMatch.players[winnerDest.slot] = null;
          if (targetMatch.elements && targetMatch.elements.scoreInputs[winnerDest.slot]) {
            targetMatch.elements.scoreInputs[winnerDest.slot].value = '';
          }
          updateMatchDisplay(targetMatch);
        }
        match.propagated.winner = null;
      }

      const loserDest = match.propagated.loser;
      if (loserDest) {
        const targetMatch = state.matches.get(loserDest.matchId);
        if (targetMatch && targetMatch.completed) {
          showToast('Cannot change this result because downstream matches are already decided.');
          return false;
        }
        if (targetMatch) {
          const occupant = targetMatch.players[loserDest.slot];
          if (occupant && occupant.losses > 0) {
            occupant.losses -= 1;
          }
          targetMatch.players[loserDest.slot] = null;
          if (targetMatch.elements && targetMatch.elements.scoreInputs[loserDest.slot]) {
            targetMatch.elements.scoreInputs[loserDest.slot].value = '';
          }
          updateMatchDisplay(targetMatch);
        }
        match.propagated.loser = null;
      }

      match.completed = false;
      match.winnerSlot = null;
      match.scores = [null, null];
      if (match.elements) {
        match.elements.scoreInputs.forEach(input => {
          input.value = '';
          input.disabled = !(match.players[0] && match.players[1] && !match.players[0].isBye && !match.players[1].isBye);
        });
          if (match.elements.completeBtn) {
            match.elements.completeBtn.disabled = !(match.players[0] && match.players[1] && !match.players[0].isBye && !match.players[1].isBye);
          }
        }
        updateMatchDisplay(match);
        return true;
      }

      function placePlayerInMatch(match, slot, player, meta) {
        if (!match.players) return;
        const existing = match.players[slot];
        if (existing && existing.id !== player.id) {
          // Overwrite only if slot is free or placeholder
        }
        match.players[slot] = player;
        if (match.elements) {
          match.elements.scoreInputs[slot].value = '';
        }
        updateMatchDisplay(match);
        attemptAutoAdvance(match);
      }

      function handleCompleteMatch(matchId) {
        const match = state.matches.get(matchId);
        if (!match) return;
        if (match.completed) {
          showToast('Match already completed. Reset if you need to change it.');
          return;
        }
        const p0 = match.players[0];
        const p1 = match.players[1];
        if (!p0 || !p1) {
          showToast('Both slots must be filled before recording a result.');
          return;
        }
        if (p0.isBye || p1.isBye) {
          attemptAutoAdvance(match);
          return;
        }
        const input0 = match.elements.scoreInputs[0];
        const input1 = match.elements.scoreInputs[1];
        const s0 = parseInt(input0.value, 10);
        const s1 = parseInt(input1.value, 10);
        if (Number.isNaN(s0) || Number.isNaN(s1)) {
          showToast('Enter scores for both players.');
          return;
        }
        if (s0 === s1) {
          showToast('Scores cannot be tied in elimination matches.');
          return;
        }
        const winnerSlot = s0 > s1 ? 0 : 1;
        finalizeMatch(match, winnerSlot, [s0, s1]);
      }

      function handleResetMatch(matchId) {
        const match = state.matches.get(matchId);
        if (!match) return;
        if (!match.players[0] && !match.players[1]) {
          showToast('Nothing to reset for this match.');
          return;
        }
        if (!clearMatchOutcome(match)) {
          return;
        }
        updateMatchDisplay(match);
        showToast('Match reset.');
      }

      function createTournament(players, type) {
        const sorted = sortPlayersForSeeding(players);
        const bracketSize = nextPowerOfTwo(sorted.length);
        const winnersStructure = buildWinnersBracket(sorted, bracketSize);
        const winnersRounds = winnersStructure.rounds;
        const matchesById = winnersStructure.matchesById;

        const tournament = {
          type,
          size: bracketSize,
          players: sorted,
          entryFormat: state.entryFormat,
          winners: {
            rounds: winnersRounds,
          },
          losers: { rounds: [] },
          finalMatch: null,
          matchMap: matchesById,
        };

        let grandFinal = null;
        if (type === 'double') {
          grandFinal = buildGrandFinal(matchesById);
          tournament.finalMatch = grandFinal;

          const winnersRoundsCount = winnersRounds.length;
          const lastWinnersRound = winnersRounds[winnersRoundsCount - 1];
          const winnersFinal = lastWinnersRound ? lastWinnersRound[0] : null;
          if (winnersFinal) {
            winnersFinal.nextMatchId = grandFinal.id;
            winnersFinal.nextSlot = 0;
            grandFinal.sources[0] = winnersFinal.id;
            grandFinal.sourceMeta[0] = { type: 'winner', from: winnersFinal.id };
            grandFinal.slotAnnotations[0] = 'Winner of ' + winnersFinal.id;
          }

          if (winnersRoundsCount > 1) {
            const losersStructure = buildLosersBracket(winnersRounds, matchesById, grandFinal);
            tournament.losers = losersStructure;
          } else if (winnersFinal) {
            winnersFinal.loserDest = { matchId: grandFinal.id, slot: 1 };
            winnersFinal.loserDestLabel = 'Loser → ' + grandFinal.id;
            grandFinal.sources[1] = winnersFinal.id;
            grandFinal.sourceMeta[1] = { type: 'loser', from: winnersFinal.id };
            grandFinal.slotAnnotations[1] = 'Loser of ' + winnersFinal.id;
          }
        } else {
          tournament.matchMap = matchesById;
        }

        tournament.matchMap = matchesById;
        return tournament;
      }

      function handleCreateDraw() {
        try {
          const players = readPlayersFromTable();
          if (players.length < 2) {
            showToast('Enter at least two players.');
            return;
          }
          const typeInput = document.querySelector('input[name="elimination"]:checked');
          if (!typeInput) {
            showToast('Select an elimination type.');
            return;
          }
          const type = typeInput.value;
          state.tournament = createTournament(players, type);
          renderTournament(state.tournament);
          showToast('Bracket created.');
        } catch (err) {
          showToast(err.message || 'Unable to create bracket.');
        }
      }

      function init() {
        state.entryFormat = getEntryFormat();
        clearPlayers();
        applyFormatToRows(state.entryFormat);
        entryFormatInputs.forEach(input => {
          input.addEventListener('change', handleFormatChange);
        });
        if (introPlayerList && introPlayerList.children.length === 0) {
          createIntroPlayerRow();
        }
        if (introAddPlayerBtn) {
          introAddPlayerBtn.addEventListener('click', () => createIntroPlayerRow());
        }
        if (introForm) {
          introForm.addEventListener('submit', handleIntroSubmit);
        }
        if (introSkipBtn) {
          introSkipBtn.addEventListener('click', () => {
            hideIntroOverlay();
          });
        }
        addPlayerBtn.addEventListener('click', () => createPlayerRow());
        clearPlayersBtn.addEventListener('click', () => {
          clearPlayers();
          bracketContainer.innerHTML = '<div class="empty-state">Add at least two players and click "Create draw" to see the bracket.</div>';
        });
        createDrawBtn.addEventListener('click', handleCreateDraw);
      }

      init();
    })();
</script>
